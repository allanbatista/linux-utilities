#!/usr/bin/env python3
"""
auto-commit - Automatically generate commit messages using LLM.

Captures uncommitted changes and generates appropriate commit messages.
"""
import argparse
import os
import re
import sys

from ab_cli.core.config import get_config, estimate_tokens, get_language
from ab_cli.commands.prompt import send_to_openrouter
from ab_cli.utils import (
    log_info,
    log_success,
    log_warning,
    log_error,
    RED,
    GREEN,
    YELLOW,
    BLUE,
    NC,
    is_git_repo,
    get_repo_root,
    get_current_branch,
    is_protected_branch,
    create_branch,
    get_staged_files,
    get_unstaged_files,
    get_untracked_files,
    get_staged_diff,
    get_staged_name_status,
    stage_all_files,
    create_commit,
    get_latest_commit,
    get_recent_commits,
)


def suggest_branch_name(diff: str, name_status: str, lang: str) -> str:
    """Generate a suggested branch name based on changes."""
    config = get_config()

    prompt_text = f"""Analyze these git changes and suggest a branch name.

RULES:
1. Return ONLY the branch name, nothing else
2. Use lowercase kebab-case (words-separated-by-dashes)
3. Max 50 characters total
4. Choose appropriate prefix based on change type:
   - feature/ for new features
   - fix/ for bug fixes
   - chore/ for maintenance tasks
   - refactor/ for code refactoring
   - docs/ for documentation
   - test/ for test-related changes
5. Be concise but descriptive

FILES CHANGED:
{name_status}

DIFF PREVIEW (first 1000 chars):
{diff[:1000]}

Return ONLY the branch name:"""

    estimated_tokens = estimate_tokens(prompt_text)
    selected_model = config.select_model(estimated_tokens)
    timeout_s = config.get_with_default('global.timeout_seconds')
    api_key_env = config.get_with_default('global.api_key_env')
    api_base = config.get_with_default('global.api_base')

    try:
        result = send_to_openrouter(
            prompt=prompt_text,
            context="",
            lang=lang,
            specialist=None,
            model_name=selected_model,
            timeout_s=timeout_s,
            max_completion_tokens=-1,  # No limit
            api_key_env=api_key_env,
            api_base=api_base
        )

        if not result:
            log_error("API call failed for branch suggestion")
            return ""

        branch_name = result.get('text', '').strip()

        if not branch_name:
            log_error("LLM returned empty response for branch name")
            return ""

        # Clean up
        branch_name = branch_name.strip('"\'`')
        branch_name = branch_name.split('\n')[0].strip()
        branch_name = re.sub(r'\s+', '-', branch_name)
        branch_name = re.sub(r'[^a-zA-Z0-9/_-]', '', branch_name)
        if len(branch_name) > 50:
            branch_name = branch_name[:50].rstrip('-')

        if not branch_name:
            log_error("Branch name became empty after cleanup")
            return ""

        return branch_name
    except Exception as e:
        log_error(f"Exception suggesting branch name: {e}")
        return ""


def generate_commit_message(diff: str, name_status: str, recent_commits: str,
                           lang: str) -> str:
    """Generate commit message using the LLM."""
    config = get_config()

    # Build the prompt
    prompt_text = f"""Analyze the git changes below and generate ONLY the commit message, without additional explanations.

RULES:
1. Respond ONLY with the commit message, nothing else
2. Write in language: {lang}
3. Be concise and descriptive
4. First line: summary up to 100 characters (if possible)
5. If needed, add details after a blank line
6. Use bullet points for content after the first line
7. Do NOT add any footer, attribution, or "Generated by" text

RECENT COMMITS (style reference):
{recent_commits}

FILES CHANGED:
{name_status}

DIFF:
{diff}

Respond ONLY with the commit message:
"""

    # Estimate tokens and select model
    estimated_tokens = estimate_tokens(prompt_text)
    selected_model = config.select_model(estimated_tokens)
    timeout_s = config.get_with_default('global.timeout_seconds')
    api_key_env = config.get_with_default('global.api_key_env')
    api_base = config.get_with_default('global.api_base')

    log_info(f"Estimated tokens: ~{estimated_tokens} | Model: {selected_model} | Lang: {lang}")
    print()

    result = send_to_openrouter(
        prompt=prompt_text,
        context="",
        lang=lang,
        specialist=None,
        model_name=selected_model,
        timeout_s=timeout_s,
        max_completion_tokens=-1,
        api_key_env=api_key_env,
        api_base=api_base
    )

    if not result:
        raise RuntimeError("API call failed for commit message generation")

    return result.get('text', '').strip()


def handle_protected_branch(current_branch: str, diff: str, name_status: str,
                            lang: str) -> bool:
    """Handle protected branch workflow. Returns True if should continue, False to abort."""
    log_warning(f"You are on '{current_branch}' branch.")
    print()

    # Try to suggest a branch name
    log_info("Suggesting branch name...")
    suggested_branch = suggest_branch_name(diff, name_status, lang)

    if suggested_branch:
        print(f"\n{GREEN}Suggested branch:{NC} {YELLOW}{suggested_branch}{NC}\n")
    else:
        log_warning("Could not suggest branch name")
        print()

    print("Options:")
    if suggested_branch:
        print(f"  {GREEN}[1]{NC} Create suggested branch '{suggested_branch}'")
    else:
        print(f"  {GREEN}[1]{NC} (unavailable - suggestion failed)")
    print(f"  {BLUE}[2]{NC} Enter branch name manually")
    print(f"  {YELLOW}[3]{NC} Commit directly on {current_branch}")
    print(f"  {RED}[4]{NC} Cancel")
    print()

    try:
        choice = input("Choice [1/2/3/4]: ").strip()
    except EOFError:
        choice = '4'

    if choice == '1' and suggested_branch:
        if create_branch(suggested_branch):
            log_success(f"Created and switched to '{suggested_branch}'")
            return True
        else:
            log_error("Failed to create branch")
            sys.exit(1)
    elif choice == '2':
        try:
            manual_branch = input("Enter branch name: ").strip()
        except EOFError:
            manual_branch = ''

        if manual_branch:
            if create_branch(manual_branch):
                log_success(f"Created and switched to '{manual_branch}'")
                return True
            else:
                log_error("Failed to create branch")
                sys.exit(1)
        else:
            log_warning("No branch name provided. Cancelled.")
            sys.exit(0)
    elif choice == '3':
        log_info(f"Continuing on {current_branch}...")
        return True
    else:
        log_warning("Cancelled")
        sys.exit(0)

    return False


def main():
    parser = argparse.ArgumentParser(
        description='Automatically generates commit messages using the prompt utility',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Examples:
  auto-commit                    # Generate message and confirm
  auto-commit -y -a              # Stage all and commit without confirmation
  auto-commit -l pt-br           # Generate message in Portuguese
'''
    )

    parser.add_argument('-y', '--yes', action='store_true',
                        help='Skip commit confirmation')
    parser.add_argument('-a', '--add', action='store_true',
                        help='Automatically stage all files')
    parser.add_argument('-l', '--lang', type=str,
                        default=get_language('auto-commit'),
                        help=f'Output language (default: {get_language("auto-commit")})')

    args = parser.parse_args()

    # Check if inside git repo
    if not is_git_repo():
        log_error("Not inside a git repository")
        sys.exit(1)

    # Change to repo root
    os.chdir(get_repo_root())

    # Check if on protected branch FIRST
    current_branch = get_current_branch()
    on_protected_branch = is_protected_branch(current_branch)

    log_info("Checking for uncommitted changes...")

    # Check for changes
    staged = get_staged_files()
    unstaged = get_unstaged_files()
    untracked = get_untracked_files()

    if not staged and not unstaged and not untracked:
        log_warning("No changes to commit")
        sys.exit(0)

    # Show summary
    print()
    log_info("Changes summary:")

    if staged:
        print(f"{GREEN}Staged:{NC}")
        for f in staged.split('\n'):
            print(f"  {f}")

    if unstaged:
        print(f"{YELLOW}Modified:{NC}")
        for f in unstaged.split('\n'):
            print(f"  {f}")

    if untracked:
        print(f"{RED}Untracked:{NC}")
        for f in untracked.split('\n'):
            print(f"  {f}")

    print()

    # Handle staging
    if unstaged or untracked:
        if args.add:
            log_info("Staging all files (--add)...")
            stage_all_files()
        else:
            try:
                reply = input("Stage all files? (y/N) ").strip().lower()
            except EOFError:
                reply = 'n'

            if reply == 'y':
                log_info("Staging files...")
                stage_all_files()
            elif not staged:
                log_warning("No files staged. Aborting.")
                sys.exit(0)

    # Get the diff
    log_info("Generating diff for analysis...")
    diff = get_staged_diff()

    if not diff:
        log_warning("No staged changes to commit")
        sys.exit(0)

    # Get context
    recent_commits = get_recent_commits(5)
    name_status = get_staged_name_status()

    # Handle protected branch (after staging so we have the diff for suggestions)
    if on_protected_branch:
        handle_protected_branch(current_branch, diff, name_status, args.lang)

    # Generate commit message
    log_info("Generating commit message...")

    try:
        commit_msg = generate_commit_message(
            diff, name_status, recent_commits, args.lang
        )
    except Exception as e:
        log_error(f"Failed to generate commit message: {e}")
        sys.exit(1)

    if not commit_msg:
        log_error("Failed to generate commit message")
        sys.exit(1)

    # Show generated message
    print(f"{GREEN}Generated commit message:{NC}")
    print("-" * 40)
    print(commit_msg)
    print("-" * 40)
    print()

    # Confirm commit
    if not args.yes:
        try:
            reply = input("Confirm commit with this message? (Y/n) ").strip().lower()
        except EOFError:
            reply = 'n'

        if reply == 'n':
            log_warning("Commit cancelled")
            sys.exit(0)

    # Create commit
    log_info("Committing...")
    create_commit(commit_msg)

    print()
    log_success("Commit successful!")
    log_info(f"Latest commit: {get_latest_commit()}")


if __name__ == '__main__':
    main()
