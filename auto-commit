#!/bin/bash

# Script para auto-commit usando o utilitário prompt
# Captura alterações não commitadas e gera mensagem de commit adequada

set -e

# Resolve caminho do script e do prompt
SCRIPT_PATH="$(readlink -f -- "${BASH_SOURCE[0]}")"
SCRIPT_DIR="$(dirname -- "$SCRIPT_PATH")"
PROMPT_CMD="$SCRIPT_DIR/prompt"

# Modelos por limite de tokens
MODEL_SMALL="nvidia/nemotron-3-nano-30b-a3b:free"  # até 128k tokens
MODEL_MEDIUM="openai/gpt-5-nano"                    # até 256k tokens
MODEL_LARGE="x-ai/grok-4.1-fast"                    # acima de 256k tokens

# Função para estimar tokens (aproximadamente 4 caracteres por token)
estimate_tokens() {
    local text="$1"
    local chars=$(echo -n "$text" | wc -c)
    echo $(( chars / 4 ))
}

# Função para selecionar modelo baseado no tamanho
select_model() {
    local tokens="$1"
    if [ "$tokens" -le 128000 ]; then
        echo "$MODEL_SMALL"
    elif [ "$tokens" -le 256000 ]; then
        echo "$MODEL_MEDIUM"
    else
        echo "$MODEL_LARGE"
    fi
}

# Cores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Função para log
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Mostra ajuda
show_help() {
    echo "Usage: auto-commit [options]"
    echo ""
    echo "Automatically generates commit messages using the prompt utility"
    echo ""
    echo "Options:"
    echo "  -y, --yes             Skip commit confirmation"
    echo "  -a, --add             Automatically stage all files"
    echo "  -l, --lang LANG       Output language (default: en)"
    echo "  -h, --help            Show this help"
    echo ""
    echo "Examples:"
    echo "  auto-commit                    # Generate message and confirm"
    echo "  auto-commit -y -a              # Stage all and commit without confirmation"
    echo "  auto-commit -l pt-br           # Generate message in Portuguese"
}

# Parse argumentos
AUTO_ADD=false
SKIP_CONFIRM=false
LANG="en"

while [[ $# -gt 0 ]]; do
    case $1 in
        -y|--yes)
            SKIP_CONFIRM=true
            shift
            ;;
        -a|--add)
            AUTO_ADD=true
            shift
            ;;
        -l|--lang)
            LANG="$2"
            shift 2
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        *)
            log_error "Unknown option: $1"
            show_help
            exit 1
            ;;
    esac
done

# Verifica se está em um repositório git
if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
    log_error "Not inside a git repository"
    exit 1
fi

# Verifica se o prompt está disponível
if [ ! -x "$PROMPT_CMD" ]; then
    log_error "Utility 'prompt' not found at $SCRIPT_DIR"
    exit 1
fi

# Navega para a raiz do repositório
cd "$(git rev-parse --show-toplevel)"

log_info "Checking for uncommitted changes..."

# Verifica se há alterações
STAGED=$(git diff --cached --name-only)
UNSTAGED=$(git diff --name-only)
UNTRACKED=$(git ls-files --others --exclude-standard)

if [ -z "$STAGED" ] && [ -z "$UNSTAGED" ] && [ -z "$UNTRACKED" ]; then
    log_warning "No changes to commit"
    exit 0
fi

# Mostra resumo das alterações
echo ""
log_info "Changes summary:"

if [ -n "$STAGED" ]; then
    echo -e "${GREEN}Staged:${NC}"
    echo "$STAGED" | sed 's/^/  /'
fi

if [ -n "$UNSTAGED" ]; then
    echo -e "${YELLOW}Modified:${NC}"
    echo "$UNSTAGED" | sed 's/^/  /'
fi

if [ -n "$UNTRACKED" ]; then
    echo -e "${RED}Untracked:${NC}"
    echo "$UNTRACKED" | sed 's/^/  /'
fi

echo ""

# Pergunta se deve adicionar arquivos não staged
if [ -n "$UNSTAGED" ] || [ -n "$UNTRACKED" ]; then
    if [ "$AUTO_ADD" = true ]; then
        log_info "Staging all files (--add)..."
        git add -A
    else
        read -p "Stage all files? (y/N) " -n 1 -r
        echo ""
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            log_info "Staging files..."
            git add -A
        elif [ -z "$STAGED" ]; then
            log_warning "No files staged. Aborting."
            exit 0
        fi
    fi
fi

# Gera o diff para análise
log_info "Generating diff for analysis..."
DIFF=$(git diff --cached)

if [ -z "$DIFF" ]; then
    log_warning "No staged changes to commit"
    exit 0
fi

# Obtém os últimos commits para contexto de estilo
RECENT_COMMITS=$(git log --oneline -5 2>/dev/null || echo "")

# Cria arquivo temporário para o prompt (evita problemas com tamanho)
PROMPT_FILE=$(mktemp)
trap "rm -f $PROMPT_FILE" EXIT

cat > "$PROMPT_FILE" << EOF
Analyze the git changes below and generate ONLY the commit message, without additional explanations.

RULES:
1. Respond ONLY with the commit message, nothing else
2. Write in language: $LANG
3. Be concise and descriptive
4. First line: summary up to 100 characters (if possible)
5. If needed, add details after a blank line
6. Use bullet points for content after the first line
7. Do NOT add any footer, attribution, or "Generated by" text

RECENT COMMITS (style reference):
$RECENT_COMMITS

FILES CHANGED:
$(git diff --cached --name-status)

DIFF:
$DIFF

Respond ONLY with the commit message:
EOF

# Estima tokens e seleciona modelo
ESTIMATED_TOKENS=$(estimate_tokens "$(cat "$PROMPT_FILE")")
SELECTED_MODEL=$(select_model "$ESTIMATED_TOKENS")

# Executa o prompt e captura a mensagem (usa stdin para evitar "Argument list too long")
log_info "Generating commit message..."
log_info "Estimated tokens: ~$ESTIMATED_TOKENS | Model: $SELECTED_MODEL | Lang: $LANG"
echo ""

COMMIT_MSG=$("$PROMPT_CMD" --model "$SELECTED_MODEL" --lang "$LANG" --max-completion-tokens -1 --only-output --prompt - < "$PROMPT_FILE")

if [ -z "$COMMIT_MSG" ]; then
    log_error "Failed to generate commit message"
    exit 1
fi

# Mostra a mensagem gerada
echo -e "${GREEN}Generated commit message:${NC}"
echo "----------------------------------------"
echo "$COMMIT_MSG"
echo "----------------------------------------"
echo ""

# Confirma o commit
if [ "$SKIP_CONFIRM" = false ]; then
    read -p "Confirm commit with this message? (Y/n) " -n 1 -r
    echo ""

    if [[ $REPLY =~ ^[Nn]$ ]]; then
        log_warning "Commit cancelled"
        exit 0
    fi
fi

# Executa o commit
log_info "Committing..."
git commit -m "$COMMIT_MSG"

echo ""
log_success "Commit successful!"
log_info "Latest commit: $(git log -1 --oneline)"
