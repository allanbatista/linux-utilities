#!/bin/bash

# Script para auto-commit usando o utilitário prompt
# Captura alterações não commitadas e gera mensagem de commit adequada

set -e

# Resolve caminho do script e do prompt
SCRIPT_PATH="$(readlink -f -- "${BASH_SOURCE[0]}")"
SCRIPT_DIR="$(dirname -- "$SCRIPT_PATH")"
PROMPT_CMD="$SCRIPT_DIR/prompt"

# Modelos por limite de tokens
MODEL_SMALL="nvidia/nemotron-3-nano-30b-a3b:free"  # até 128k tokens
MODEL_MEDIUM="openai/gpt-5-nano"                    # até 256k tokens
MODEL_LARGE="x-ai/grok-4.1-fast"                    # acima de 256k tokens

# Função para estimar tokens (aproximadamente 4 caracteres por token)
estimate_tokens() {
    local text="$1"
    local chars=$(echo -n "$text" | wc -c)
    echo $(( chars / 4 ))
}

# Função para selecionar modelo baseado no tamanho
select_model() {
    local tokens="$1"
    if [ "$tokens" -le 128000 ]; then
        echo "$MODEL_SMALL"
    elif [ "$tokens" -le 256000 ]; then
        echo "$MODEL_MEDIUM"
    else
        echo "$MODEL_LARGE"
    fi
}

# Cores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Função para log
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Mostra ajuda
show_help() {
    echo "Uso: auto-commit [opções]"
    echo ""
    echo "Gera mensagem de commit automaticamente usando o utilitário prompt"
    echo ""
    echo "Opções:"
    echo "  -y, --yes             Pula confirmação do commit"
    echo "  -a, --add             Adiciona todos os arquivos automaticamente"
    echo "  -h, --help            Mostra esta ajuda"
    echo ""
    echo "Exemplos:"
    echo "  auto-commit                    # Gera mensagem e confirma"
    echo "  auto-commit -y -a              # Adiciona tudo e commita sem confirmar"
}

# Parse argumentos
AUTO_ADD=false
SKIP_CONFIRM=false

while [[ $# -gt 0 ]]; do
    case $1 in
        -y|--yes)
            SKIP_CONFIRM=true
            shift
            ;;
        -a|--add)
            AUTO_ADD=true
            shift
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        *)
            log_error "Opção desconhecida: $1"
            show_help
            exit 1
            ;;
    esac
done

# Verifica se está em um repositório git
if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
    log_error "Não está em um repositório git"
    exit 1
fi

# Verifica se o prompt está disponível
if [ ! -x "$PROMPT_CMD" ]; then
    log_error "Utilitário 'prompt' não encontrado em $SCRIPT_DIR"
    exit 1
fi

# Navega para a raiz do repositório
cd "$(git rev-parse --show-toplevel)"

log_info "Verificando alterações não commitadas..."

# Verifica se há alterações
STAGED=$(git diff --cached --name-only)
UNSTAGED=$(git diff --name-only)
UNTRACKED=$(git ls-files --others --exclude-standard)

if [ -z "$STAGED" ] && [ -z "$UNSTAGED" ] && [ -z "$UNTRACKED" ]; then
    log_warning "Não há alterações para commitar"
    exit 0
fi

# Mostra resumo das alterações
echo ""
log_info "Resumo das alterações:"

if [ -n "$STAGED" ]; then
    echo -e "${GREEN}Staged:${NC}"
    echo "$STAGED" | sed 's/^/  /'
fi

if [ -n "$UNSTAGED" ]; then
    echo -e "${YELLOW}Modified:${NC}"
    echo "$UNSTAGED" | sed 's/^/  /'
fi

if [ -n "$UNTRACKED" ]; then
    echo -e "${RED}Untracked:${NC}"
    echo "$UNTRACKED" | sed 's/^/  /'
fi

echo ""

# Pergunta se deve adicionar arquivos não staged
if [ -n "$UNSTAGED" ] || [ -n "$UNTRACKED" ]; then
    if [ "$AUTO_ADD" = true ]; then
        log_info "Adicionando arquivos ao stage (--add)..."
        git add -A
    else
        read -p "Adicionar todos os arquivos ao stage? (y/N) " -n 1 -r
        echo ""
        if [[ $REPLY =~ ^[Yy]$ ]]; then
            log_info "Adicionando arquivos ao stage..."
            git add -A
        elif [ -z "$STAGED" ]; then
            log_warning "Nenhum arquivo no stage. Abortando."
            exit 0
        fi
    fi
fi

# Gera o diff para análise
log_info "Gerando diff para análise..."
DIFF=$(git diff --cached)

if [ -z "$DIFF" ]; then
    log_warning "Nenhuma alteração no stage para commitar"
    exit 0
fi

# Obtém os últimos commits para contexto de estilo
RECENT_COMMITS=$(git log --oneline -5 2>/dev/null || echo "")

# Cria arquivo temporário para o prompt (evita problemas com tamanho)
PROMPT_FILE=$(mktemp)
trap "rm -f $PROMPT_FILE" EXIT

cat > "$PROMPT_FILE" << EOF
Analise as alterações git abaixo e gere APENAS a mensagem de commit, sem explicações adicionais.

REGRAS:
1. Responda SOMENTE com a mensagem de commit, nada mais
2. Use português brasileiro
3. Seja conciso e descritivo
4. Primeira linha: resumo em até 100 caracteres (se possível)
5. Se necessário, adicione detalhes após linha em branco
6. a mensagem de commit deve ser em US-en
7. use bullet points para o conteúdo após a primeira linha

COMMITS RECENTES (referência de estilo):
$RECENT_COMMITS

ARQUIVOS ALTERADOS:
$(git diff --cached --name-status)

DIFF:
$DIFF

Responda APENAS com a mensagem de commit:
EOF

# Estima tokens e seleciona modelo
PROMPT_CONTENT=$(cat "$PROMPT_FILE")
ESTIMATED_TOKENS=$(estimate_tokens "$PROMPT_CONTENT")
SELECTED_MODEL=$(select_model "$ESTIMATED_TOKENS")

# Executa o prompt e captura a mensagem
log_info "Gerando mensagem de commit..."
log_info "Tokens estimados: ~$ESTIMATED_TOKENS | Modelo: $SELECTED_MODEL"
echo ""

COMMIT_MSG=$("$PROMPT_CMD" --model "$SELECTED_MODEL" --max-completion-tokens -1 --only-output --prompt "$PROMPT_CONTENT")

if [ -z "$COMMIT_MSG" ]; then
    log_error "Falha ao gerar mensagem de commit"
    exit 1
fi

# Mostra a mensagem gerada
echo -e "${GREEN}Mensagem de commit gerada:${NC}"
echo "----------------------------------------"
echo "$COMMIT_MSG"
echo "----------------------------------------"
echo ""

# Confirma o commit
if [ "$SKIP_CONFIRM" = false ]; then
    read -p "Confirmar commit com esta mensagem? (Y/n) " -n 1 -r
    echo ""

    if [[ $REPLY =~ ^[Nn]$ ]]; then
        log_warning "Commit cancelado"
        exit 0
    fi
fi

# Executa o commit
log_info "Executando commit..."
git commit -m "$COMMIT_MSG"

echo ""
log_success "Commit realizado com sucesso!"
log_info "Último commit: $(git log -1 --oneline)"
