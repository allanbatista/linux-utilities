#!/bin/bash

# Script para gerar título e descrição de PR usando o utilitário prompt
# Analisa commits e diff relativos à branch base

set -e

# Resolve caminho do script e do prompt
SCRIPT_PATH="$(readlink -f -- "${BASH_SOURCE[0]}")"
SCRIPT_DIR="$(dirname -- "$SCRIPT_PATH")"
PROMPT_CMD="$SCRIPT_DIR/prompt"

# Modelos por limite de tokens
MODEL_SMALL="nvidia/nemotron-3-nano-30b-a3b:free"  # até 128k tokens
MODEL_MEDIUM="openai/gpt-5-nano"                    # até 256k tokens
MODEL_LARGE="x-ai/grok-4.1-fast"                    # acima de 256k tokens

# Função para estimar tokens (aproximadamente 4 caracteres por token)
estimate_tokens() {
    local text="$1"
    local chars=$(echo -n "$text" | wc -c)
    echo $(( chars / 4 ))
}

# Função para selecionar modelo baseado no tamanho
select_model() {
    local tokens="$1"
    if [ "$tokens" -le 128000 ]; then
        echo "$MODEL_SMALL"
    elif [ "$tokens" -le 256000 ]; then
        echo "$MODEL_MEDIUM"
    else
        echo "$MODEL_LARGE"
    fi
}

# Cores para output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Função para log
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Função para detectar branch base
detect_base_branch() {
    # Prioridade: main > master > develop
    for branch in main master develop; do
        if git show-ref --verify --quiet "refs/heads/$branch" 2>/dev/null; then
            echo "$branch"
            return 0
        fi
    done

    # Fallback: tenta remoto
    for branch in main master develop; do
        if git show-ref --verify --quiet "refs/remotes/origin/$branch" 2>/dev/null; then
            echo "origin/$branch"
            return 0
        fi
    done

    echo ""
    return 1
}

# Mostra ajuda
show_help() {
    echo "Uso: pr-description [opções]"
    echo ""
    echo "Gera título e descrição de PR automaticamente usando o utilitário prompt"
    echo ""
    echo "Opções:"
    echo "  -b, --base BRANCH     Branch base (default: auto-detect main/master)"
    echo "  -c, --create          Cria PR usando gh CLI"
    echo "  -d, --draft           Cria como draft (requer -c)"
    echo "  -y, --yes             Pula confirmação"
    echo "  -h, --help            Mostra esta ajuda"
    echo ""
    echo "Exemplos:"
    echo "  pr-description                    # Gera título e descrição"
    echo "  pr-description -c                 # Gera e cria PR"
    echo "  pr-description -c -d              # Cria PR como draft"
    echo "  pr-description -b develop -c -y   # Cria PR para develop sem confirmar"
}

# Parse argumentos
BASE_BRANCH=""
CREATE_PR=false
IS_DRAFT=false
SKIP_CONFIRM=false

while [[ $# -gt 0 ]]; do
    case $1 in
        -b|--base)
            BASE_BRANCH="$2"
            shift 2
            ;;
        -c|--create)
            CREATE_PR=true
            shift
            ;;
        -d|--draft)
            IS_DRAFT=true
            shift
            ;;
        -y|--yes)
            SKIP_CONFIRM=true
            shift
            ;;
        -h|--help)
            show_help
            exit 0
            ;;
        *)
            log_error "Opção desconhecida: $1"
            show_help
            exit 1
            ;;
    esac
done

# Verifica se está em um repositório git
if ! git rev-parse --is-inside-work-tree > /dev/null 2>&1; then
    log_error "Não está em um repositório git"
    exit 1
fi

# Verifica se o prompt está disponível
if [ ! -x "$PROMPT_CMD" ]; then
    log_error "Utilitário 'prompt' não encontrado em $SCRIPT_DIR"
    exit 1
fi

# Verifica se gh está instalado (se --create)
if [ "$CREATE_PR" = true ]; then
    if ! command -v gh &> /dev/null; then
        log_error "gh CLI não está instalado. Instale com: sudo apt install gh"
        exit 1
    fi

    # Verifica autenticação do gh
    if ! gh auth status &> /dev/null; then
        log_error "gh não está autenticado. Execute: gh auth login"
        exit 1
    fi
fi

# Navega para a raiz do repositório
cd "$(git rev-parse --show-toplevel)"

# Detecta branch base se não especificada
if [ -z "$BASE_BRANCH" ]; then
    BASE_BRANCH=$(detect_base_branch)
    if [ -z "$BASE_BRANCH" ]; then
        log_error "Não foi possível detectar branch base. Use -b para especificar."
        exit 1
    fi
fi

# Obtém branch atual
CURRENT_BRANCH=$(git rev-parse --abbrev-ref HEAD)

log_info "Branch atual: $CURRENT_BRANCH"
log_info "Branch base: $BASE_BRANCH"

# Verifica se não está na branch base
if [ "$CURRENT_BRANCH" = "$BASE_BRANCH" ]; then
    log_error "Você está na branch base ($BASE_BRANCH). Crie uma feature branch primeiro."
    exit 1
fi

# Verifica se há commits ahead
COMMITS_AHEAD=$(git rev-list --count "$BASE_BRANCH..$CURRENT_BRANCH" 2>/dev/null || echo "0")

if [ "$COMMITS_AHEAD" = "0" ]; then
    log_warning "Nenhum commit ahead de $BASE_BRANCH"
    exit 0
fi

log_info "Commits ahead: $COMMITS_AHEAD"
echo ""

# Captura commits e diff
log_info "Analisando alterações..."

COMMITS=$(git log --oneline "$BASE_BRANCH..$CURRENT_BRANCH" 2>/dev/null || echo "")
DIFF=$(git diff "$BASE_BRANCH...$CURRENT_BRANCH" 2>/dev/null || echo "")
FILES_CHANGED=$(git diff --name-status "$BASE_BRANCH...$CURRENT_BRANCH" 2>/dev/null || echo "")

if [ -z "$DIFF" ]; then
    log_warning "Nenhuma alteração detectada em relação a $BASE_BRANCH"
    exit 0
fi

# Cria arquivo temporário para o prompt
PROMPT_FILE=$(mktemp)
trap "rm -f $PROMPT_FILE" EXIT

cat > "$PROMPT_FILE" << EOF
Analise os commits e alterações abaixo e gere título e descrição para um Pull Request.

REGRAS:
1. Responda EXATAMENTE no formato especificado abaixo
2. Título: máximo 72 caracteres, conciso e descritivo, em inglês
3. Descrição em inglês
4. Use bullet points no Summary (2-4 pontos principais)
5. Liste apenas os arquivos mais relevantes em Changes
6. Sugira 2-4 testes em Testing

BRANCH: $CURRENT_BRANCH
BASE: $BASE_BRANCH

COMMITS:
$COMMITS

ARQUIVOS ALTERADOS:
$FILES_CHANGED

DIFF:
$DIFF

FORMATO DE RESPOSTA (siga exatamente):
TITLE: <título conciso aqui>

DESCRIPTION:
## Summary
- ponto 1
- ponto 2

## Changes
- arquivo: descrição da alteração

## Testing
- [ ] teste 1
- [ ] teste 2
EOF

# Estima tokens e seleciona modelo
ESTIMATED_TOKENS=$(estimate_tokens "$(cat "$PROMPT_FILE")")
SELECTED_MODEL=$(select_model "$ESTIMATED_TOKENS")

# Executa o prompt (usa stdin para evitar "Argument list too long")
log_info "Gerando título e descrição do PR..."
log_info "Tokens estimados: ~$ESTIMATED_TOKENS | Modelo: $SELECTED_MODEL"
echo ""

RESPONSE=$("$PROMPT_CMD" --model "$SELECTED_MODEL" --max-completion-tokens -1 --only-output --prompt - < "$PROMPT_FILE")

if [ -z "$RESPONSE" ]; then
    log_error "Falha ao gerar descrição do PR"
    exit 1
fi

# Extrai título e descrição
PR_TITLE=$(echo "$RESPONSE" | sed -n 's/^TITLE: *//p' | head -1)
PR_BODY=$(echo "$RESPONSE" | sed -n '/^DESCRIPTION:/,$p' | tail -n +2)

# Fallback se parsing falhar
if [ -z "$PR_TITLE" ]; then
    PR_TITLE=$(echo "$RESPONSE" | head -1)
fi

if [ -z "$PR_BODY" ]; then
    PR_BODY="$RESPONSE"
fi

# Mostra resultado
echo -e "${GREEN}Título do PR:${NC}"
echo "----------------------------------------"
echo "$PR_TITLE"
echo "----------------------------------------"
echo ""
echo -e "${GREEN}Descrição do PR:${NC}"
echo "----------------------------------------"
echo "$PR_BODY"
echo "----------------------------------------"
echo ""

# Confirma ação
if [ "$CREATE_PR" = true ]; then
    if [ "$SKIP_CONFIRM" = false ]; then
        read -p "Criar PR com este conteúdo? (Y/n) " -n 1 -r
        echo ""

        if [[ $REPLY =~ ^[Nn]$ ]]; then
            log_warning "Criação do PR cancelada"
            exit 0
        fi
    fi

    # Monta flags
    DRAFT_FLAG=""
    if [ "$IS_DRAFT" = true ]; then
        DRAFT_FLAG="--draft"
    fi

    # Cria o PR
    log_info "Criando PR..."

    PR_URL=$(gh pr create --title "$PR_TITLE" --body "$PR_BODY" --base "$BASE_BRANCH" $DRAFT_FLAG 2>&1)

    if [ $? -eq 0 ]; then
        echo ""
        log_success "PR criado com sucesso!"
        log_info "URL: $PR_URL"
    else
        log_error "Falha ao criar PR: $PR_URL"
        exit 1
    fi
else
    log_info "Use -c para criar o PR automaticamente"
fi
